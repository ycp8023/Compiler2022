[TOC]

llvm-link llvm_ir.txt lib.ll -S -o out.ll


### 普通符号表

整个编译器维护一个符号栈 `Symstack`

| 某个块的符号表（symtable） |
| :------------------------- |
| 某个块的符号表（symtable） |
| 某个块的符号表（symtable） |
| 某个块的符号表（symtable） |

编译到的当前符号表：`tmptab`




第一遍：source读入字符串到strList中

第二遍：遍历strList，通过词法分析程序tokenizer，得到**词法分析结果tklist**

第三遍：遍历tklist，通过语法分析程序CompUnit，建立符号表并进行错误处理和语法分析，得到**错误处理结果errorlist**和**语法分析结果anslist**

## 词法分析lexical

Source:读入并建立存储单词值与类别码键值对的map

```
List<String> strList 		    #读入字符串
HashMap<String,String> map		#(单词值，类别码)键值对	Ident：如if，else…
HashMap<String,String> otkmap	#(单词值，类别码)键值对	符号：如(，[
```

- #### Token：

  String tktype	类别码	String value	 值		int value		行数

- #### Tokenizer:

```
Source source;						        
DataOutputStream dout;					词法分析输出流
ArrayList<Token> tklist;				词法分析处理结果
```

词法分析流程：

处理双引号和空格，得到由String和“String”组成的 `ArrayList<String> strings`。

开始匹配单个字符：取出当前String

1. 若string首尾为“”，则通过FormatStringck检测是否符合格式字符串

## 语法分析syntax

改写文法，消除左递归：

```
CompUnit → {Decl} {FuncDef} MainFuncDef
Decl → ConstDecl | VarDecl
ConstDecl → 'const' BType ConstDef { ',' ConstDef } ';'
ConstDef → Ident { '[' ConstExp ']' } '=' ConstInitVal
ConstInitVal → ConstExp  | '{' [  ConstInitVal { ',' ConstInitVal } ] '}'
VarDecl → BType VarDef { ',' VarDef } ';'
VarDef → Ident { '[' ConstExp ']' }| Ident { '[' ConstExp ']' } '=' InitVal
InitVal → Exp | '{' [ InitVal { ',' InitVal } ] '}'
FuncDef → FuncType Ident '(' [FuncFParams] ')' Block
MainFuncDef → 'int' 'main' '(' ')' Block
FuncFParams → FuncFParam { ',' FuncFParam }
FuncFParam → BType Ident ['[' ']' { '[' ConstExp ']' }]
Block → '{' { BlockItem } '}'
BlockItem → Decl | Stmt
Stmt → LVal '=' Exp ';' 
                | [Exp] ';' 
                | Block
                | 'if' '(' Cond ')' Stmt [ 'else' Stmt ] 
                | 'while' '(' Cond ')' Stmt
                | 'break' ';'
                | 'continue' ';'
                | 'return' [Exp] ';' // 1.有Exp 2.无Exp
                | LVal '=' 'getint''('')'';'
                | 'printf''('FormatString{','Exp}')'';'
 rewrite:  Stmt' ->   <AssignStmt> | <ExpStmt> | <Block> | <IfStmt> | <Whilestmt>                       | <BreakStmt> | <ContinueStmt> | <ReturnStmt> | <InputStmt> | <OutputStmt>
<Assignstmt>:	LVal '=' Exp ';'
<Expstmt>:		[Exp] ';'
<ifstmt>:		'if' '(' Cond ')' Stmt [ 'else' Stmt ]
<whilestmt>:	'while' '(' Cond ')' Stmt
<Breakstmt>:	'break' ';'
<Continuestmt>:	'continue' ';'
<Returnstmt>:	'return' [Exp] ';'
<Inputstmt>:	LVal '=' 'getint''('')'';'
<Outputstmt>:	'printf''('FormatString{','Exp}')'';'
Exp → AddExp
Cond → LOrExp
LVal → Ident {'[' Exp ']'}
PrimaryExp → '(' Exp ')' | LVal | Number
PrimaryExp | FuncCall
<UnaryExp>->{UnaryOp} Baseunaryexp
UnaryOp → '+' | '−' | '!'
FuncRParams → Exp { ',' Exp }
<MulExp> := <UnaryExp> { ('*' | '/' | '%') <UnaryExp> }
<AddExp>  := <MulExp> { ('+' | '-') <MulExp> }
<RelExp> := <AddExp> { ('<' | '>' | '<=' | '>=') <AddExp> }
<EqExp> := <RelExp> { ('==' | '!=') <RelExp> }
<LAndExp> := <EqExp> { '&&' <EqExp> }
<LOrExp> := <LAndExp> { '||' <LAndExp> }
ConstExp → AddExp
```

某成分分析函数（）

```
int start=anslist.len()-1;				
Token mark=tmp;
int tmppos=pos;						
int tmpline=0;						//用于错误处理记录错误的行号
//		分析程序
//当前符合：
anslist.add(tmp);
[tmp=getsym();]
//a.分析结果符合：
Token out=new Token("out","<成分>",-1);
anslist.add(out);
return true;
//b.分析结果不符合
tmp=mark;
pos=tmppos;
anslist.del(start);					//清空anslist从index为start开始的el
return false;	
```

- #### CompUnit：语法分析结果

```
public ArrayList<Token> tklist;				词法分析结果
public DataOutputStream dout;				语法分析输出
public DataOutputStream errdout;			错误处理输出
public Anslist anslist;						语法分析结果
public int pos=-1;
public Token tmp;							全局变量记录当前读到的token
public Errorlist errorlist;					 错误处理结果
public Symstack symstack;   //symstack in main
public Symtable tmptab;     //symtable in symstack
public Token tmpident;
public String funcname;         //name of tmp func
public String tmpfunctype;      //type of tmp func
public int expval;           //to check param type
public String tmpbtype;
public int ifreturn;           //to check if func is returned
public int markline;           //to mark the linenum of the error
public int mark4semi;          //to mark the linenum of the semicn check
public int whileblock;
public int cnt_formatc;
public int arrindex;
public String funccallname;
public HashMap<String, Functable> funcsym;     //symtables of functions
public LinkedList<String> funcstack;           //only note the order of funccall/blocks
```

- #### Anslist：语法分析结果

```
List<Token> tokens = new LinkedList<>();
```

## 符号表symbol

- #### Functable(int nameline,String functype)：某函数的符号表

  （函数名所在行，函数返回值类型）

```
public HashMap<String, Value> functable;       	 函数的符号表<符号名，符号属性>
public HashMap<String,Funcvalue> funcparams;     函数的参数表<参数名,参数属性>
public HashMap<Integer,String> funcpos;			函数参数位置表<第几个参数，参数名>
public int nameline;                          	 函数名所在行
public String functype;      				    函数返回值类型		
```

- #### Funcvalue（int type,int level,int line)：函数参数的属性

```
public int level;					
public int line;       参数所在行
public int dimsize;    参数维数
public int type;       参数类型：//-1:void	0:int   1:1 dim arr   2:2 dim arr
```

- #### Symtable(int level):某block的符号表

```
public HashMap<String, Value> symtable		符号表<符号名，符号属性>
public int level;			                该符号表的level			  				   
```

- #### Value：符号属性

```
public int level;
public int line;       符号所在行
public int dimsize;    符号维数
public int type;       符号类型：1:const   0:var   -1:funcname     -2:funcparams
```

- #### symstack()：函数运行栈

```
public LinkedList<Symtable> symstack;		函数运行栈
```

int type：1:const   0:var   -1:funcname     -2:funcparams
int line:
int level: