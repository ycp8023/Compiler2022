# 编译设计文档

[TOC]

## 一、参考编译器介绍

PL0编译器

基本按照词法分析，语法分析，错误处理中间代码生成，解释执行的顺序组织文档。语法分析过程中进行错误处理，其余语法成分分析结构基本同常量声明类似。

```
begin { main }    { 主函数 }
... ...
  getsym;    {获取第一个词的标识符}
  block( 0,0,[period]+declbegsys+statbegsys );    {执行主程序block}
 
... ...
  then interpret    {解释执行生成的PCODE代码}
  else write('ERRORS IN PL/0 PROGRAM');    {否则报错}
  writeln;    {换行}
  close(fin);    {关闭源文件程序}
  readln(sfile);  
end.           
...
procedure constdeclaration;     {常量声明}
    begin
      if sym = ident    
      then begin
             getsym;  
             if sym in [eql,becomes]  
             then begin
                    if sym = becomes   
                    then error(1);   
                    getsym;  
                    if sym = number  
                    then begin
                           enter(constant);  
                           getsym   
                         end
                    else error(2)   
                  end
             else error(3)   
           end
      else error(4)   
    end; { constdeclaration }
...
procedure gen( x: fct; y,z : integer );    {目标代码生成过程,x表示PCODE指令,y,z是指令的两个操作数}
procedure block( lev,tx : integer; fsys : symset );    {语法分析的主程序}
procedure getsym;    {词法分析程序}
procedure error( n : integer );  {错误处理程序}
procedure interpret;  {解释执行程序}
...
  table : array[0..txmax] of    {符号表}
                record 
                  name : alfa; 
                  case kind: objecttyp of    
                    constant : (val:integer );   
                    variable,prosedure: (level,adr: integer )
                end;
...
```

## 二、编译器总体设计

总体结构：

编译器入口文件为Compiler。

第一遍，通过source将字符串读入到strList中，并建立存储单词值与类别码键值对的map

第二遍，遍历strList，通过词法分析程序tokenize，将生成的词法分析结果存入tklist

第三遍，遍历tklist，通过语法分析程序Compunit，生成语法树ast并建立符号表，将生成的语法分析结果存入anslist，同时在语法分析过程中，进行错误处理。

第四遍，遍历语法树ast，通过中间代码生成程序llvmir，得到生成的中间代码llvm

文件组织：

src目录下文件结构：

- frontend：前端相关
  - ast：语法树相关
    - Node：语法树结点
    - Tree：语法树
  - error：错误处理相关
    - Error：错误
    - Errorlist：错误处理结果
  - lexical：词法分析相关
    - Token：标识符
    - Tokenizer：词法分析主要程序
  - symbol：符号表相关
    - Arraytemplate：数组模板
    - Functable：函数表
    - Funcvalue：函数相关信息
    - Stack4block：针对整个语法树的栈式符号表，是一个以stack4node为元素的链表（用于语法树构建，第二版符号表）
    - Stack4node：针对某个block的栈式符号表，包括一个以结点为元素的链表（用于语法树构建，第二版符号表）
    - Symstack：栈式符号表，以symtable 为元素的链表（第一版符号表）
    - Symtable：存储某一个符号的信息，包含一个用于存储符号名和符号信息键值对的哈希表（第一版符号表）
    - Table4func：针对每个定义的函数，单独建的一个符号表，存储函数名，函数参数，函数调用相关信息，主要在中间代码生成阶段使用
    - Value：符号相关信息，即symtable中哈希表中的符号信息所用的数据结构
  - syntax：语法分析相关
    - Anslist.java：存储语法分析结果
    - CompUnit.java：语法分析主处理程序
  - Source.java ：用于读入的程序，将字符串读入到strList中（按行存储），并建立存储单词值与类别码键值对的map，便于下一步进行词法分析
- middle：
  - expcal：表达式计算相关
    - Numstack：数字栈
    - Opstack：符号栈
    - Pair
  - ProdIR：中间代码生成程序
- Compiler：编译器入口程序

## 三、词法分析设计

编码前的设计：

在Compiler主程序中实例化Tokenizer类，在Tokenizer类中的tokenize方法中完成词法分析，并将结果输出到tokenize.txt。

词法分析流程：

遍历strlist：

①双引号和空格预处理：处理后得到的字符串存储导strings中，strings中的字符串除了输出中的内容不去除空格外，其余均为单词，得到的strings可用于下一步处理

```java
//双引号处理
String[] IOstr = tmpline.split("\"");
 ArrayList<String> strings = new ArrayList<>();
//空格处理
for (int i = 0; i < IOstr.length; i++) {
    if (i >=1 && i%2==1&& i+1<IOstr.length) {
         strings.add("\"" + IOstr[i] + "\"");
    }
     else {
          for (String str : IOstr[i].split("\\s+")) {
              strings.add(str);
          }
     }
}
```

②注释处理

```java
//                 multi-annotation
                    pos = tokenck("/\\*", sb.toString());
                    if (pos != -1 &&flag==0) {
                        flag = 1;
                        sb = sb.delete(0, pos);
                    }
                    pos = sb.indexOf("*/");
                    if (pos != -1 &&flag==1) {
                        flag = 0;
                        sb = sb.delete(0, pos+2);
                        continue;
                    }
//                    onlyleft
                    if(flag==1 && pos==-1) break;

//                  singo-annotation
                    pos=tokenck("//",sb.toString());
                    if(pos!=-1){
                        singoanno=1;
                        break;
                    }
```

③词法分析：

一般有三类：Ident，IntConst，FormatString。其中Ident的判断要注意将与特殊中相同的例如“main” 一类的符号剔除。这三类通过Identck，Formatck和Intconstck函数实现判断

特殊还可以分两类：一类是“main","const"等类似Ident的符号（strict-token），另一类为 “+”， “||” 等不为Ident的符号（oe-token）。

其中oe-token和strict-token中，符号与类别码的对应关系已经在词法分析前的source读入阶段，建立过hashmap，方便判断出类别后，迅速获取相关信息。

- 判断是否通过Identck，若通过说明可能是Ident或者strick-token，故接着分别判断是否通过strick-token，若通过则为strict-token，否则为Ident-token
- 若未通过Identck，逐一判断是否是oe-token
- 若不是oe-token，判断是否通过intconstck，若通过则为intconst

找到匹配的信息后，即可按照要求输出

```java
//    oe-token匹配检查
    public static int tokenck(String pattern, String str) {
        Matcher m = Pattern.compile(pattern).matcher(str);
        if (m.lookingAt())
            return m.end();
        return -1;
    }
//    strict-token匹配检查
    public static int strtkck(String pattern,String str){
        if(str.equals(pattern))
            return 1;
        return -1;
    }
//    Ident匹配检查
    public static int Identck(String str) {
        String Identp = "^([a-z]|[A-Z]|_)(\\w*)";
        Matcher m = Pattern.compile(Identp).matcher(str);
        if (m.lookingAt()) {
            return m.end();
        }
        return -1;
    }
//    Int匹配检查
    public static int Intconstck(String str) {
        String Intconstp = "^-?\\d+";
        Matcher m = Pattern.compile(Intconstp).matcher(str);
        if (m.lookingAt()) {
            return m.end();
        }
        return -1;
    }
//    FormatString匹配检查
    public static int FormatStringck(String str) {
        String FormatStringp = "^\"((%d)*|([\\x20,\\x21,\\x28-\\x7E])*)*\"$";
        Matcher m = Pattern.compile(FormatStringp).matcher(str);
        if (m.lookingAt()) {
            StringBuffer sb=new StringBuffer(str);
            int mark1=sb.indexOf("\\");
            int mark2;
            while(mark1!=-1){
                sb.delete(0, mark1+1);
                mark2=sb.indexOf("n");
                if(mark2!=0)
                    return -1;
                sb.delete(0,1);
                mark1=sb.indexOf("\\");
            }
            return m.end();
        }
        return -1;
    }
```

编码完成后修改：

为了语法分析过程，新建了tklist用于存储词法分析结果。此外，为了调试方便，将相关输入输出放到了Compiler主文件中，即tokenizer修改后的tokenizer类主要属性方法如下：

```java
    public Source source;
    public DataOutputStream dout;
    public ArrayList<Token> tklist;
    public Tokenizer(Source source, DataOutputStream tokendout){
        this.source=source;
        this.dout=tokendout;
    };
    public ArrayList<Token> tokenize(Source source)
    ... ...
```

## 四. 语法分析设计

语法分析相关主要在syntax文件夹中

编码前设计：

①改写文法并消除左递归：除了消除左递归，也可以考虑向前看实现

```java
<LVal>          := Ident { '[' <Exp> ']' } // public class LVal { ident, class Index, List<Index> }
<PrimaryExp>    := <SubExp> | <LVal> | <Number> // Look forward: '(' :: <SubExp>, <Ident> :: <LVal>, <IntConst> :: <Number>
<SubExp>        := '(' <Exp> ')'
<Number>        := IntConst  
<BaseUnaryExp> :=  PrimaryExp | FuncCall
<FuncCall>  := <Ident> '(' [ <FuncRParams> ] ')'
<FuncRParams>   := <Exp> { ',', <Exp> } // List<Exp>
<UnaryExp>      := { <UnaryOp> } <BaseUnaryExp> 
<MulExp>        := <UnaryExp> { ('*' | '/' | '%') <UnaryExp> }   
<AddExp>        := <MulExp> { ('+' | '-') <MulExp> }
<RelExp>        := <AddExp> { ('<' | '>' | '<=' | '>=') <AddExp> }
<EqExp>         := <RelExp> { ('==' | '!=') <RelExp> }
<LAndExp>       := <EqExp> { '&&' <EqExp> }
<LOrExp>        := <LAndExp> { '||' <LAndExp> }

<Exp>           := <AddExp> // public class Exp extends AddExp { }
<Cond>          := <LOrExp> // public class Cond extends LOrExp { }
<ConstExp>      := <AddExp>
Stmt → LVal '=' Exp ';' 
//                | [Exp] ';' //有无Exp两种情况
//                | Block
//                | 'if' '(' Cond ')' Stmt [ 'else' Stmt ] // 1.有else 2.无else
//                | 'while' '(' Cond ')' Stmt
//                | 'break' ';'
//                | 'continue' ';'
//                | 'return' [Exp] ';'
//                | LVal '=' 'getint''('')'';'
//                | 'printf''('FormatString{','Exp}')'';'
//     rewrite:  Stmt' ->   <AssignStmt> | <ExpStmt> | <Block> | <IfStmt> | <Whilestmt>
//                         | <BreakStmt> | <ContinueStmt> | <ReturnStmt> | <InputStmt> | <OutputStmt>
<BlockItem>     := <Decl> | <Stmt>
<Block>         := '{' { <BlockItem> } '}'
<Decl>          := <ConstDecl> | <VarDecl>
<BType>         := 'int'
// Const
<ConstDecl>     := 'const' <BType> <ConstDef> { ',' <ConstDef> } ';'
<ConstDef>      := Ident { '[' <ConstExp> ']' } '=' <ConstInitVal>
<ConstInitVal>  := <ConstExp> | '{' [ <ConstInitVal> { ',' <ConstInitVal> } ] '}'
// Var
<VarDecl>       := <BType> <VarDef> { ',' <VarDef> } ';'
<VarDef>        := Ident { '[' <ConstExp> ']' } | Ident { '[' <ConstExp> ']' } '=' <InitVal>
<InitVal>       := <Exp> | '{' [ <InitVal> { ',' <InitVal> } ] '}'
```

②递归下降进行分析：以Compunit为例

```java
    public void Compunit(){
//        CompUnit → {Decl} {FuncDef} MainFuncDef
        tmp=getsym();
        while(true){
            if(Decl()) {
                continue;
            }
            break;
        }
        while(true){
            if(Funcdef())  {
                printfuncstack();
                continue;
            }
            break;
        }
        if(Mainfuncdef()){
            Token out=new Token("out","<CompUnit>",-1);
            anslist.add(out);
        }
        anslist.output();
    }
```

将语法分析结束后的anslist输出即为语法分析结果

编码后修改：

在错误处理阶段，发现语法分析过程中没有建符号表，于是补充了符号表

在中间代码生成阶段，发现需要语法树，于是重新补充了第二版符号表和语法树

结点类：

该结点类为实现中间代码生成后的最终版，生成语法树阶段，保留父节点`fnode`和子节点列表`sonlist` 和`token`字段即可

```java
public class Node {
    public String nodetype;                 //e.g:<MainFuncDef>/<leaf>
    public String val;                      //e.g:vn/val
    public Token token;
    public List<Node> sonlist;
    public Node fnode;
    public int reg;                         //寄存器编号
    public int isglobal;
    public int intval;                      //该结点数值integer
    public Arraytemplate arraytemplate;
    public int isarr;
    public int truereg;
    public int falsereg;
    public int storereg;
    public String type;
}
```

语法树类：

```java
    public Node root;
    public Tree(Node root){
        this.root=root;
    }
    public void insert(Node pnode,Node cnode){
        pnode.sonlist.add(cnode);
        cnode.setFnode(pnode);
    }
    public void print(Node n, DataOutputStream dout)
```

其中最重要的是insert方法，通过传入父节点pnode和子节点cnode，完成结点插入。

由于是在语法分析基础上重构语法树，并不想对原来语法分析代码做太多修改，所以增加了一个以node为元素的链表：nodelist，用于存储当前语法分析出的结点序列，然后在进行结点插入时，直接取最后一个元素即可。分析过程中，每分析到一个语法成分，就建立一个结点，分析结束后将该结点添加到nodelist中。参考如下：

```java
 public void Compunit(){
//        CompUnit → {Decl} {FuncDef} MainFuncDef
        tmp=getsym();
        while(true){
            if(Decl()) {
                ast.insert(root,nodelist.getLast());
                continue;
            }
            break;
        }
        while(true){
            if(Funcdef())  {
                printfuncstack();
                ast.insert(root,nodelist.getLast());
                continue;
            }
            break;
        }
        if(Mainfuncdef()){
            Token out=new Token("out","<CompUnit>",-1);
            anslist.add(out);
            ast.insert(root,nodelist.getLast());
        }
        anslist.output();
        errorlist.output();
    }
```



## 五. 错误处理设计

编码前设计：

①首先，完成符号表的建立

符号表相关

`Symtable`    是通过语法树建立的符号表，每一个block（每个level）产生一个，主要包括一个存储符号名和属性键值对的哈希表和一个level属性

```java
    public HashMap<String, Value> symtable=new HashMap<String,Value>();
    public int level;
```

`Symstack` 	是整个程序的符号栈，由多个Symtable组成。根据编译进度，对Symtable进行压栈和弹栈操作，主要包括一个以symtable为元素的链表作为符号栈

```java
    public LinkedList<Symtable> symstack;
```

`Value` 	是符号表中，每个符号属性的数据结构。level即所在域，line是所在行数，dimsize是维度(默认数组为数组维度，否则为0)；type是类型，arrinfo作为数组模板

```java
    public int level;
    public int line;       //line of symbol
    public int dimsize;    //dim of symbol
    public int type;       //1:const   0:var   -1:funcname     -2:funcparams
    public Arraytemplate arrinfo;
```

②根据要求，进行错误处理即可，错误处理结果存到errorlist中

Error的数据结构

```java
public class Error {
    public String code;
    public int line;
    public Error(String code,int line){
        this.code=code;
        this.line=line;
    }
}
```

编码后修改：无修改

错误处理阶段没有遇到实现上的困难，最大的问题在于辅助评测太弱，本身代码逻辑并不能做到十分完善，辅助评测即使全部通过，正式评测仍然只能通过两个样例，大部分时间在处理逻辑问题的bug。后来发现的最佳解决方案是：使用用例库中的正确程序测试。

## 六. 代码生成设计

代码生成主要根据语法树进行，整体架构跟语法树类似。对建立完成的语法树进行自顶向下的前序遍历，针对每个语法成分进行中间代码的生成。

主要遇到的困难，第一是代码生成二中对数组的引入，第二是函数调用和定义相关参数信息的存储，第三是条件语句和循环语句的跳转问题，第四是条件语句中的条件判断问题，如LAndExp，LOrExp，Exexp，Relexp等

为了方便函数相关信息的存储，代码生成阶段又维护了一个符号表，其中对于函数的处理采用Table4func数据结构。主要包括了函数名funcname，返回值类型rettype，函数参数结点funcparams，存储参数名和参数值键值对的parammap，存储参数位置和参数名键值对的indexmap，函数调用结点funcrparams。

```java
	public String funcname;
    public String rettype;
    public ArrayList<Node> funcparams;          //以防万一缺少信息
    public HashMap<String,Arraytemplate> parammap;      //参数名和参数值对应
    public HashMap<Integer, String> indexmap;           //参数位置和参数名对应
    public List<Node> funcrparams;                 //函数调用信息,每次调用结束后清除
```

对于数组的引入，采用数组模板Arraytemplate数据结构存储相关信息。

xrange为第一维大小，yrange为第二维大小，onedimarr为一维数组存储的值，twodimarr为二维数组存储的值，以一维index和二维arraylist组成键值对的方式存储，elptr_reg1和elptr_reg2分别存储对应的一维/二维在getelementptr时的reg，reg为该数组的reg

```java
    public int xrange;
    public int yrange;
    public int dimsize;
    public ArrayList<Integer> onedimarr;
    public HashMap<Integer,ArrayList<Integer>> twodimarr;       //      <x,y>即 twodimarr.get(x).get(y);
    public int elptr_reg1;
    public int elptr_reg2;
    public int reg;
```

然后就可以开始根据llvm运行结果，对不同语法成分进行中间代码生成，中间代码生成程序ProdIR整体架构同语法分析程序CompUnit类似，区别是在对应语法成分函数中不是进行语法分析，而是生成对应中间代码，例如：

```java
    public void CompUnit(Node node){
//        CompUnit → {Decl} {FuncDef} MainFuncDef
        for(Node n:node.sonlist){
            visit(n);
        }
    }
	public void Mainfuncdef(Node node) {
//        MainFuncDef → 'int' 'main' '(' ')' Block
        reg=1;
        IRlist.add("define dso_local i32 @main() {\n");
        IRlist.add(tabs(level+1)+"%"+reg+" = alloca i32\n");retreg=reg;reg++;
        System.out.println(node.sonlist.get(4));
        visit(node.sonlist.get(4));
        IRlist.add("}\n");
    }
```

对于条件语句和循环语句，可以先写成波兰表达式，明确label位置后再进行

```java
        'if' '(' Cond ')' 【label1】Stmt 【label2】['else'Stmt ]【endlabel】
        'if' '(' Cond ')' 【label1】Stmt 【endlabel】
        'while' 【label1】'(' Cond ')' 【label2】Stmt【label3】
```

对于LAndExp，LOrExp，Exexp，Relexp，采用`icmp` 比较之后得到的reg是用于直接跳转的，若想要转为数字，需要使用`zext`